---
title: 'Stress Testing Concurrent Features in React 18'
publishedAt: 'May 24, 2022'
description: ''
cover: '/optimized/articles/concurrent-react-18/hero.webp'
category: 'Rust'
coverWidth: '1400'
coverHeight: '600'
---

## TL;DR

---

<img
  src="/optimized/articles/concurrent-react-18/screenshot.webp"
  alt="Demo screen shot"
  width="100%"
  className="rounded centered"
  loading="lazy"
/>

## Create Basic 3D View with React Three Fiber

```tsx:pages/index.tsx
import type { NextPage } from 'next';
import { Canvas } from '@react-three/fiber';
import { OrbitControls } from '@react-three/drei';
import Sphere from '../components/Sphere';
import Particles from '../components/Particles';

const Home: NextPage = () => {
  return (
    <main>
      {/* 3D Rendering */}
      <Canvas>
        <OrbitControls />
        <hemisphereLight args={['#ffffff', '#ffffff', 3]} />
        {/* The Earth */}
        <Sphere position={[0, 0, 0]} />
        {/* The Stars */}
        <Particles />
      </Canvas>
    </main>
  )
}

export default Home;
```

```tsx:components/Sphere.tsx
import { useLoader } from '@react-three/fiber';
import { TextureLoader } from 'three';
import { memo } from 'react';

function Sphere(props: JSX.IntrinsicElements['mesh']) {
  const texture = useLoader(TextureLoader, 'https://i.imgur.com/45naBE9.jpg');

  return (
    <mesh {...props} scale={1}>
      <sphereGeometry args={[2, 32, 16]} />
      <meshPhongMaterial map={texture} />
    </mesh>
  );
}

export default memo(Sphere);
```

```tsx:components/Particles.tsx
import { useRef, useEffect, useTransition, useState, memo } from 'react';
import { BufferGeometry, MathUtils, Float32BufferAttribute } from 'three';
import randomColor from 'randomcolor';

type ParticlesProps = {
  trigger?: boolean;
};

function Particles({ trigger }: ParticlesProps) {
  const geometry = useRef<BufferGeometry>(null);
  const [color, setColor] = useState('#888888');
  const [, startTransition] = useTransition();

  useEffect(() => {
      const vertices = [];

      for (let i = 0; i < 100_000; i++) {
        const x = MathUtils.randFloatSpread(2000);
        const y = MathUtils.randFloatSpread(2000);
        const z = MathUtils.randFloatSpread(2000);

        vertices.push(x, y, z);
      }

      geometry.current?.setAttribute(
        'position',
        new Float32BufferAttribute(vertices, 3),
      );

      setColor(randomColor());
  }, [trigger]);

  return (
    <mesh>
      <points>
        <bufferGeometry ref={geometry} />
        <pointsMaterial color={color} />
      </points>
    </mesh>
  );
}

export default memo(Particles);
```

## Twinkle The Stars

```tsx:pages.index.tsx
// inside the page component
const [trigger, setTrigger] = useState(false);

// send the trigger to the particles every second
useEffect(() => {
  const interval = setInterval(() => {
    setTrigger(!trigger);
  }, 1000);
  return () => {
    clearInterval(interval);
  };
}, [trigger])

// ...

return (
  <main>
    {/* ... */}
    <Particles trigger={trigger}>
  </main>
)
```

## Add Input Field to Fetch GitHub User and Connections

```diff:pages/index.tsx
// ...
+ import {
+   useEffect,
+   useState,
+   ChangeEvent,
+   useCallback,
+   KeyboardEvent,
+ } from 'react';

const Home: NextPage = () => {
+  const [username, setUsername] = useState<string>('');
+  const handleChange = (e: ChangeEvent<HTMLInputElement>) => {
+    setUsername(e.target.value);
+  };

+  const handleKeyPress = useCallback(
+    (e: KeyboardEvent<HTMLInputElement>) => {
+      if (e.key === 'Enter' && username !== '') {
+        fetchUserConnections({ variables: { login: username } });
+      }
+    },
+    [username],
+  );
  // ...
  return (
    <main>
+     <input
+       value={username}
+       onChange={handleChange}
+       onKeyPress={handleKeyPress}
+       placeholder="Enter GitHub username"
+     />
      {/* 3D Rendering */}
    </main>
  );
};
```

```ts:service/userConnection.ts
import { gql } from '@apollo/client';

interface User {
  id: string;
  location: string | null;
}

interface Connection {
  following: {
    nodes: User[];
  };
  followers: {
    nodes: User[];
  };
}

export interface UserConnectionsQuery {
  user: User & Connection;
}

export const USER_CONNECTIONS = gql`
  query GetUserConnections($login: String!) {
    user(login: $login) {
      id
      location
      following(first: 100) {
        nodes {
          id
          location
        }
      }
      followers(first: 100) {
        nodes {
          id
          location
        }
      }
    }
  }
`;
```

```tsx:pages/index.tsx
import { useLazyQuery } from '@apollo/client';
import {
  UserConnectionsQuery,
  USER_CONNECTIONS,
} from '../services/userConnections';

const Home: NextPage = () => {
  // ...
  const [fetchUserConnections, { data, loading }] = useLazyQuery<
    UserConnectionsQuery
  >(USER_CONNECTIONS)

  const handleChange = (e: ChangeEvent<HTMLInputElement>) => {
    setUsername(e.target.value);
  };

  const handleKeyPress = useCallback(
    (e: KeyboardEvent<HTMLInputElement>) => {
      if (e.key === 'Enter' && username !== '') {
        fetchUserConnections({ variables: { login: username } });
      }
    },
    [username],
  );
  // ...
}
```

## Convert Cities to Coordinates

```ts:pages/api/coordinates.ts
import type { NextApiRequest, NextApiResponse } from 'next';
import cities from 'all-the-cities';

interface ReqBody {
  origin: string;
  destinations: Record<'id' | 'location', string>[];
}

interface Data {
  origin: number[];
  destinations: {
    id: string;
    coordinates: number[];
  }[];
}

type ArrayElement<ArrayType> = ArrayType extends readonly (infer ElementType)[]
  ? ElementType
  : never;

const match = (location: string) => (city: ArrayElement<typeof cities>) => {
  const token = location.split(/[,*\s+]+/).join('|');
  const regex = new RegExp(token, 'ig');
  return city.name.match(regex);
};

export default async function handler(
  req: NextApiRequest,
  res: NextApiResponse<Data>,
) {
  if (req.method !== 'POST') {
    res.status(405);
    return;
  }
  const { origin, destinations }: ReqBody = req.body;

  const org = cities
    .filter(match(origin))
    .filter((_, i) => i === 0)
    .map((c) => [...c.loc.coordinates].reverse())
    .flat();

  const dst = destinations.reduce((acc, loc) => {
    return [
      ...acc,
      ...cities
        .filter(match(loc.location))
        .filter((_, i) => i === 0) // take one
        .map((c) => ({
          id: loc.id,
          coordinates: [...c.loc.coordinates].reverse(),
        })),
    ];
  }, [] as Data['destinations']);

  res.status(200).json({
    origin: org.length === 0 ? [40.7128, 74.006] : org, // default to NYC
    destinations: dst,
  });
}
```

```tsx:pages/index.tsx
const [locs, setLocs] = useState<{
    origin: number[];
    destinations: { id: string; coordinates: number[] }[];
  }>({ origin: [], destinations: [] });

// fetch coordinates when user connection data is updated
useEffect(() => {
  if (data) {
    const body = JSON.stringify(prepare(data));

    fetch('/api/coordinates', {
      method: 'POST',
      headers: {
        'Content-Type': 'application/json',
      },
      body,
    })
      .then((res) => res.json())
      .then((result) => {
        setLocs(result);
      });
  }
}, [data]);
```

## Use Coordinates to Render 3D Curves

```tsx:components/Tube.tsx
import { calculateSpline } from '../utils/geo';
import { AdditiveBlending } from 'three';
import { memo } from 'react';

const CURVE_SEGMENTS = 32;
const TUBE_RADIUS_SEGMENTS = 2;
const DEFAULT_TUBE_RADIUS = 0.01;
const DRAW_RANGE_DELTA = 16;
const MAX_DRAW_RANGE = DRAW_RANGE_DELTA * CURVE_SEGMENTS;

type TubeProps = {
  coords: number[];
};

function Tube({ coords }: TubeProps) {
  const { spline } = calculateSpline(coords);

  return (
    <mesh>
      <tubeBufferGeometry
        args={[
          spline,
          CURVE_SEGMENTS,
          DEFAULT_TUBE_RADIUS,
          TUBE_RADIUS_SEGMENTS,
          false,
        ]}
        drawRange={{ start: 0, count: MAX_DRAW_RANGE }}
      />
      <meshBasicMaterial
        blending={AdditiveBlending}
        opacity={0.6}
        transparent
        color="#e43c59"
      />
    </mesh>
  );
}

export default memo(Tube);
```

To calculate spline, I followed [this formula](https://stackblitz.com/edit/webgl-globe-solutions?file=globe%2Futils.js) to create `CubicBezierCurve3`.

```diff:pages/index.tsx
return (
+   <mesh>
+     {locs.destinations.map((dest, i) => (
+       <Tube
+         key={dest.id}
+         coords={[...locs.origin, ...dest.coordinates]}
+       />
+     ))}
+   </mesh>
  <Particle trigger={trigger} />
)
```

## Measure Performance without Concurrent Features

## Use `Suspense` and `startTransition` to Enter Concurrent Mode

```diff:pages/index.tsx
import {
  useEffect,
  useState,
  ChangeEvent,
  useCallback,
  KeyboardEvent,
+ Suspense,
+ useTransition,
} from 'react';

const Home: NextPage = () => {
  // ...
+ const [, startTransition] = useTransition();

  useEffect(() => {
    const interval = setInterval(() => {
+     startTransition(() => {
        setTrigger(!trigger);
+     });
    }, 1000);
    return () => {
      clearInterval(interval);
    };
  }, [trigger]);

  return (
    <Canvas>
      <OrbitControls />
      <hemisphereLight args={['#ffffff', '#ffffff', 3]} />
      <Sphere position={[0, 0, 0]} />
+     <Suspense fallback={null}>
        <mesh>
          {locs.destinations.map((dest, i) => (
            <Tube
              key={dest.id}
              coords={[...locs.origin, ...dest.coordinates]}
            />
          ))}
        </mesh>
        <Particle trigger={trigger} />
+     </Suspense>
    </Canvas>
  );
};
```

```diff:components/Particles.tsx
+ const [, startTransition] = useTransition();

  useEffect(() => {
+   startTransition(() => {
      const vertices = [];

      // ...

      setColor(randomColor());
+   });
  }, [trigger]);
```

## Use `useDeferredValue` to Defer rendering Curves

```diff:pages/index.tsx
import {
  useEffect,
  useState,
  ChangeEvent,
  useCallback,
  KeyboardEvent,
  Suspense,
  useTransition,
  useDeferredValue
} from 'react';

const Home: NextPage = () =>
  // ...

  const [locs, setLocs] = useState<{
    origin: number[];
    destinations: { id: string; coordinates: number[] }[];
  }>({ origin: [], destinations: [] });

+ const deferredLocs = useDeferredValue(locs);

  return (
    <Canvas>
      <OrbitControls />
      <hemisphereLight args={['#ffffff', '#ffffff', 3]} />
      <Sphere position={[0, 0, 0]} />
      <Suspense fallback={null}>
        <mesh>
-         {locs.destinations.map((dest, i) => (
+         {deferredLocs.destinations.map((dest, i) => (
            <Tube
              key={dest.id}
-             coords={[...locs.origin, ...dest.coordinates]}
+             coords={[...deferredLocs.origin, ...dest.coordinates]}
            />
          ))}
        </mesh>
        <Particle trigger={trigger} />
      </Suspense>
    </Canvas>
  );
}
```

## Measure Performance with Concurrent Features

## Final Thoughts

## References

- [WebGL Globe](https://webgl-globe-solutions.stackblitz.io)

---

Here you have it! Thanks for reading through🙌
If you find this article useful, please share it to help more people in their engineering journey.

🐦 Feel free to connect with me on [twitter](https://twitter.com/dawchihliou)!

⏭ Ready for the next article? 👉 [**I Built A Snappy Static Full-text Search with WebAssembly, Rust, Next.js, and Xor Filters**](/articles/i-built-a-snappy-full-text-search-with-webassembly-rust-nextjs-and-xor-filters)

Happy coding!
