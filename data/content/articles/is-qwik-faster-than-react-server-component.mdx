---
title: 'Is Qwik Faster than React Server Component?'
publishedAt: 'Jan 26, 2023'
description: 'A benchmark comparison and analysis between Qwik and Next.js 13 + React Server Component.'
cover: '/optimized/articles/qwik-vs-next/hero.webp'
category: 'Leadership'
coverWidth: '1400'
coverHeight: '600'
---

## TL;DR

---

## How The Experiment Is Set Up

- qwik v0.16
- Next.js v13
- React v18

## Let's Peek The Result

I built an application with Qwik and Next.js and measure the performances. The demo look like this:

<img
  src="/articles/qwik-vs-next/demo.gif"
  alt="DALL-E web app demo"
  width="100%"
  className="rounded centered"
  loading="lazy"
/>

> You can find [the demo on GitHub][18]. Feel free to take a look at the repo and try it out‚ú®

The application lets users enter prompts for [DALL¬∑E][0], an AI image generator, and displays the generated images in the page. It aslo displays the latest tweets about DALL¬∑E.

The key features are:

- Server Side rendering the application.
- Client side fetching for image results with [DALL¬∑E's REST API][1].
- Server side fetching for Twitter feed with [Twitter's REST API][20].

Here's the core Web Vitals by Lighthouse for Qwik:

<img
  src="/optimized/articles/qwik-vs-next/qwik-lighthouse.webp"
  alt="Qwik Lighthouse score"
  width="100%"
  className="rounded centered"
  loading="lazy"
/>

Comparing to Next.js's Web Vitals:

<img
  src="/optimized/articles/qwik-vs-next/sc-lighthouse.webp"
  alt="Next with server component Lighthouse score"
  width="100%"
  className="rounded centered"
  loading="lazy"
/>

We can observe the following:

- Qwik's [speed index][22] is 31% faster than Next.js.
- Qwik's [time to interactive][24] is ~19% faster than Next.js.
- Next.js has a 0 ms [total blocking time][23], comparing to Qwik's 160 ms.

## The problem

## Why

## Where

## How

### Qwik

### React Server Component

## Demo

<img
  src="/optimized/articles/qwik-vs-next/qwik-perf.webp"
  alt="Qwik performance"
  width="100%"
  className="rounded centered"
  loading="lazy"
/>

<img
  src="/optimized/articles/qwik-vs-next/sc-perf.webp"
  alt="Next with server component performance"
  width="100%"
  className="rounded centered"
  loading="lazy"
/>

<img
  src="/optimized/articles/qwik-vs-next/qwik-network.webp"
  alt="Qwik network"
  width="100%"
  className="rounded centered"
  loading="lazy"
/>

<img
  src="/optimized/articles/qwik-vs-next/sc-network.webp"
  alt="Next with server component network"
  width="100%"
  className="rounded centered"
  loading="lazy"
/>

<img
  src="/optimized/articles/qwik-vs-next/qwik-serd.webp"
  alt="Qwik serialization"
  width="100%"
  className="rounded centered"
  loading="lazy"
/>

<img
  src="/articles/qwik-vs-next/qwik-dynamic-import.gif"
  alt="Qwik dynamic import"
  width="100%"
  className="rounded centered"
  loading="lazy"
/>

## Final Thoughts

## References

- [API Reference: Create image][1] - OpenAI
- [Case Study][9] - web.dev
- [Critical rendering path][12] - MDN
- [DALL¬∑E 2][0] - OpenAI
- [Data Fetching Fundamentals][17] - Next.js
- [First class support for promises][19] - Andrew Clark
- [Hydration is Pure Overhead][4] - Builder.io
- [Lighthouse performance scoring][10] - Chrome Developers
- [Lazy loading][11] - MDN
- [Node.js library][2] - OpenAI
- [Populating the page: how browsers work][16] - MDN
- [Progressively][7] - Builder.io
- [qwik][3] - Builder.io
- [qwik-vs-next][18] - Daw-Chih Liou
- [RFC: React Server Components][14] - React Community
- [Resumable vs. Hydration][6] - Builder.io
- [Reactivity][8] - Builder.io
- [Server and Client Components][13] - Next.js
- [The "why" of web performance][15] - MDN
- [Think Qwik][5] - Builder.io
- [Twitter API v2][20] - Twitter Developer Aplatform
- [Web Vitals][21] - web.dev
- [Speed Index][22] - Chrome Developers
- [Total Blocking Time][23] - Chrome Developers
- [Time to Interfactive][24] - Chrome Developers

[0]: https://openai.com/dall-e-2/
[1]: https://beta.openai.com/docs/api-reference/images/create
[2]: https://beta.openai.com/docs/libraries/node-js-library
[3]: https://qwik.builder.io
[4]: https://www.builder.io/blog/hydration-is-pure-overhead
[5]: https://qwik.builder.io/docs/think-qwik/
[6]: https://qwik.builder.io/docs/concepts/resumable/
[7]: https://qwik.builder.io/docs/concepts/progressive/
[8]: https://qwik.builder.io/docs/concepts/reactivity/
[9]: https://web.dev/tags/case-study/
[10]: https://developer.chrome.com/docs/lighthouse/performance/performance-scoring/
[11]: https://developer.mozilla.org/en-US/docs/Web/Performance/Lazy_loading
[12]: https://developer.mozilla.org/en-US/docs/Web/Performance/Critical_rendering_path
[13]: https://beta.nextjs.org/docs/rendering/server-and-client-components
[14]: https://github.com/reactjs/rfcs/blob/main/text/0188-server-components.md
[15]: https://developer.mozilla.org/en-US/docs/Learn/Performance/why_web_performance
[16]: https://developer.mozilla.org/en-US/docs/Web/Performance/How_browsers_work
[17]: https://beta.nextjs.org/docs/data-fetching/fundamentals#fetching-data-with-server-components
[18]: https://github.com/DawChihLiou/qwik-vs-next
[19]: https://github.com/acdlite/rfcs/blob/first-class-promises/text/0000-first-class-support-for-promises.md#seamless-integration-with-javascript-ecosystem
[20]: https://developer.twitter.com/en/docs/twitter-api
[21]: https://web.dev/vitals/
[22]: https://developer.chrome.com/en/docs/lighthouse/performance/speed-index/
[23]: https://developer.chrome.com/docs/lighthouse/performance/lighthouse-total-blocking-time/
[24]: https://developer.chrome.com/docs/lighthouse/performance/interactive/

---

Here you have it! Thanks for reading throughüôå
If you find this article useful, please share it to help more people in their engineering journey.

üê¶ Feel free to connect with me on [twitter](https://twitter.com/dawchihliou)!

‚è≠ Ready for the next article? üëâ [**Tired of Slow Code Reviews? Read this**](/articles/tired-of-slow-code-reviews)

Happy coding!
