---
title: 'Is Qwik Faster than React Server Component?'
publishedAt: 'Jan 26, 2023'
description: 'A benchmark comparison and analysis between Qwik and Next.js 13 + React Server Component.'
cover: '/optimized/articles/qwik-vs-next/hero.webp'
category: 'Leadership'
coverWidth: '1400'
coverHeight: '600'
---

## TL;DR

---

## How The Experiment Is Set Up

- qwik v0.16
- Next.js v13
- React v18

## Let's Peek The Result

I built two identical applications with Qwik and Next.js and measure the performances. The demo look like this:

<img
  src="/articles/qwik-vs-next/demo.gif"
  alt="DALL-E web app demo"
  width="100%"
  className="rounded centered"
  loading="lazy"
/>

> You can find [the demo on GitHub][18]. Feel free to take a look at the repo and try it out‚ú®

The application lets users enter prompts for [DALL¬∑E][0], an AI image generator, and displays the generated images in the page. It aslo displays the latest tweets about DALL¬∑E.

The key features are:

- Server Side rendering the application.
- Client side fetching for image results with [DALL¬∑E's REST API][1].
- Server side fetching for Twitter feed with [Twitter's REST API][20].

Here's the core Web Vitals by Lighthouse for Qwik:

<img
  src="/optimized/articles/qwik-vs-next/qwik-lighthouse.webp"
  alt="Qwik Lighthouse score"
  width="100%"
  className="rounded centered"
  loading="lazy"
/>

Comparing to Next.js's Web Vitals:

<img
  src="/optimized/articles/qwik-vs-next/sc-lighthouse.webp"
  alt="Next with server component Lighthouse score"
  width="100%"
  className="rounded centered"
  loading="lazy"
/>

We can observe the following:

- Qwik's [speed index][22] is 0.5 s faster than Next.js.
- Qwik's [time to interactive][24] is 0.3 s faster than Next.js.
- Next.js has a 0 ms [total blocking time][23], comparing to Qwik's 160 ms.
- Next.js has a slightly higher overall [performance score][10] by 5 points.
- Next.js's [largest contentful paint][25] is 0.8 s faster than Qwik.

Let's take a closer look at the how the frameworks handles server side rendering.

## Qwik

The component structure:

```tsx:qwik/src/routes/index.tsx
export const onGet: RequestHandler<TwitterResponse> = async () => {
  const data = await fetchTweets();
  return data;
}

export default component$(() => {
  const tweets = useEndpoint<TwitterResponse>();
  return (
    <Layout>
      <DallePromptAndResult />
      <Resource
        value={tweets}
        onResolved={(result) => (
          <SSRTwitterCarousel data={result} />
        )}
      />
      <StaticPromptRecommendation />
    </Layout>
  )
})
```

When the Qwik server recieves a page request, it starts the rendering process on the server. The "useEndPoint" funciton invokes "onGet" function on the server and fetch twitter feed. The "Resource" component will pause the rendering until the twitter data is resolved or rejected. Once the rendering is completed, the server respond the client with rendered HTML.

We can observe the server side rendering behavior in the performance analysis:

<img
  src="/optimized/articles/qwik-vs-next/qwik-perf.webp"
  alt="Qwik performance"
  width="100%"
  className="rounded centered"
  loading="lazy"
/>

The lead time to respond to the client is block by the server side data fetching and component rendering.

## Next.js

The component structure:

```tsx:next/app/page.tsx
export default async function Page() {
  const tweets = await fetchTweets();
  return (
    <Layout>
      <DallePromptAndResult />
      <Suspense fallback={<Skeleton />}>
        <SSRTwitterCarousel data={tweets} />
      </Suspense>
      <StaticPromptRecommendation />
    </Layout>
  )
}
```

When the Next.js server recieves a page reqeust, it starts [streaming][26] a React UI description in JSON to the client. The UI description is the generated by React's rendering process on the server. On the client, React progressively parse the stream and render the UI.

While the server is fetching twitter feeds, React renders the suspense placeholder to the client. Once the data is resolved or rejected, React reveals the suspense boundry and display the final UI.

<img
  src="/optimized/articles/qwik-vs-next/sc-perf.webp"
  alt="Next with server component performance"
  width="100%"
  className="rounded centered"
  loading="lazy"
/>

You can see the client starts rendering while the server is streaming. It reduces the lead time for the users to start seeing the page.

<img
  src="/optimized/articles/qwik-vs-next/qwik-network.webp"
  alt="Qwik network"
  width="100%"
  className="rounded centered"
  loading="lazy"
/>

<img
  src="/optimized/articles/qwik-vs-next/sc-network.webp"
  alt="Next with server component network"
  width="100%"
  className="rounded centered"
  loading="lazy"
/>

<img
  src="/optimized/articles/qwik-vs-next/qwik-serd.webp"
  alt="Qwik serialization"
  width="100%"
  className="rounded centered"
  loading="lazy"
/>

<img
  src="/articles/qwik-vs-next/qwik-dynamic-import.gif"
  alt="Qwik dynamic import"
  width="100%"
  className="rounded centered"
  loading="lazy"
/>

## Final Thoughts

## References

- [API Reference: Create image][1] - OpenAI
- [Case Study][9] - web.dev
- [Critical rendering path][12] - MDN
- [DALL¬∑E 2][0] - OpenAI
- [Data Fetching Fundamentals][17] - Next.js
- [First class support for promises][19] - Andrew Clark
- [Hydration is Pure Overhead][4] - Builder.io
- [Lighthouse performance scoring][10] - Chrome Developers
- [Lazy loading][11] - MDN
- [Node.js library][2] - OpenAI
- [Populating the page: how browsers work][16] - MDN
- [Progressively][7] - Builder.io
- [qwik][3] - Builder.io
- [qwik-vs-next][18] - Daw-Chih Liou
- [RFC: React Server Components][14] - React Community
- [Resumable vs. Hydration][6] - Builder.io
- [Reactivity][8] - Builder.io
- [Server and Client Components][13] - Next.js
- [The "why" of web performance][15] - MDN
- [Think Qwik][5] - Builder.io
- [Time to Interfactive][24] - Chrome Developers
- [Total Blocking Time][23] - Chrome Developers
- [Twitter API v2][20] - Twitter Developer Aplatform
- [Web Vitals][21] - web.dev
- [Speed Index][22] - Chrome Developers
- [Largest Contentful Paint][25] - Chrome Developers

[0]: https://openai.com/dall-e-2/
[1]: https://beta.openai.com/docs/api-reference/images/create
[2]: https://beta.openai.com/docs/libraries/node-js-library
[3]: https://qwik.builder.io
[4]: https://www.builder.io/blog/hydration-is-pure-overhead
[5]: https://qwik.builder.io/docs/think-qwik/
[6]: https://qwik.builder.io/docs/concepts/resumable/
[7]: https://qwik.builder.io/docs/concepts/progressive/
[8]: https://qwik.builder.io/docs/concepts/reactivity/
[9]: https://web.dev/tags/case-study/
[10]: https://developer.chrome.com/docs/lighthouse/performance/performance-scoring/
[11]: https://developer.mozilla.org/en-US/docs/Web/Performance/Lazy_loading
[12]: https://developer.mozilla.org/en-US/docs/Web/Performance/Critical_rendering_path
[13]: https://beta.nextjs.org/docs/rendering/server-and-client-components
[14]: https://github.com/reactjs/rfcs/blob/main/text/0188-server-components.md
[15]: https://developer.mozilla.org/en-US/docs/Learn/Performance/why_web_performance
[16]: https://developer.mozilla.org/en-US/docs/Web/Performance/How_browsers_work
[17]: https://beta.nextjs.org/docs/data-fetching/fundamentals#fetching-data-with-server-components
[18]: https://github.com/DawChihLiou/qwik-vs-next
[19]: https://github.com/acdlite/rfcs/blob/first-class-promises/text/0000-first-class-support-for-promises.md#seamless-integration-with-javascript-ecosystem
[20]: https://developer.twitter.com/en/docs/twitter-api
[21]: https://web.dev/vitals/
[22]: https://developer.chrome.com/en/docs/lighthouse/performance/speed-index/
[23]: https://developer.chrome.com/docs/lighthouse/performance/lighthouse-total-blocking-time/
[24]: https://developer.chrome.com/docs/lighthouse/performance/interactive/
[25]: https://developer.chrome.com/docs/lighthouse/performance/lighthouse-largest-contentful-paint/
[26]: https://beta.nextjs.org/docs/data-fetching/streaming-and-suspense

---

Here you have it! Thanks for reading throughüôå
If you find this article useful, please share it to help more people in their engineering journey.

üê¶ Feel free to connect with me on [twitter](https://twitter.com/dawchihliou)!

‚è≠ Ready for the next article? üëâ [**Tired of Slow Code Reviews? Read this**](/articles/tired-of-slow-code-reviews)

Happy coding!
