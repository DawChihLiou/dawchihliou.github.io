---
title: 'Is Qwik Faster than React Server Component?'
publishedAt: 'Jan 26, 2023'
description: 'A benchmark comparison and analysis between Qwik and Next.js 13.'
cover: '/optimized/articles/qwik-vs-next/hero.webp'
category: 'Frontend'
coverWidth: '1400'
coverHeight: '600'
---

## TL;DR

- 🔥 We'll find out whether the trending framework Qwik is faster than Next.js
- 🤖 We'll look at a demo that generates with OpenAI's DALL-E and its performance benchmark.
- 🚀 We'll discuss how Next.js leverages React server component to achieve fast SSR.

---

Page speed matters. Faster website results in [better UX, better SEO, and more profit][9]. The [latest research done by Rekuten 24][27] shows that optimizing [Core Web Vitals][21] leads to:

> - 53.37% in revenue per visitor.
> - 33.13% in conversion rate.
> - 15.20% in average order value.
> - 9.99% in average time spent.
> - A 35.12% reduction in exit rate.

The modern frameworks and frontend libraries address speed and help developers ship better user experience to the users. We'll be discussing two of the modern frameworks: [Qwik][3] and [Next.js][27]. We'll see an experiment benchmark and look into how each framework achieves optimal performance.

Let's go.

## How The Experiment Is Set Up

- qwik v0.16
- Next.js v13
- React v18

## Let's Peek The Result

I built two identical applications with Qwik and Next.js and measured the performances. The demo look like this:

<img
  src="/articles/qwik-vs-next/demo.gif"
  alt="DALL-E web app demo"
  width="100%"
  className="rounded centered"
  loading="lazy"
/>

> You can find [the demo on GitHub][18]. Feel free to take a look at the repo and try it out✨

The application lets users enter prompts to [DALL·E][0], an AI image generator, and displays the generated AI images in the page. It also displays the latest Twitter feed about DALL·E.

The key features are:

- Server Side rendering the application.
- Client side fetching the image results with [DALL·E's REST API][1].
- Server side fetching the Twitter feed with [Twitter's REST API][20].

Here's the core Web Vitals by Lighthouse for Qwik:

<img
  src="/optimized/articles/qwik-vs-next/qwik-lighthouse.webp"
  alt="Qwik Lighthouse score"
  width="100%"
  className="rounded centered"
  loading="lazy"
/>

Comparing to Next.js's Web Vitals:

<img
  src="/optimized/articles/qwik-vs-next/sc-lighthouse.webp"
  alt="Next with server component Lighthouse score"
  width="100%"
  className="rounded centered"
  loading="lazy"
/>

We can observe the following:

- Qwik's [speed index][22] is 0.5 s faster than Next.js.
- Qwik's [time to interactive][24] is 0.3 s faster than Next.js.
- Next.js has a 0 ms [total blocking time][23], comparing to Qwik's 160 ms.
- Next.js has a slightly higher overall [performance score][10] by 5 points.
- Next.js's [largest contentful paint][25] is 0.8 s faster than Qwik.

Let's take a closer look at the how the application in each framework is set up.

## Qwik Server Side Rendering

The component structure:

```tsx:qwik/src/routes/index.tsx
export const onGet: RequestHandler<TwitterResponse> = async () => {
  const data = await fetchTweets();
  return data;
}

export default component$(() => {
  const tweets = useEndpoint<TwitterResponse>();
  return (
    <Layout>
      <DallePromptAndResult />
      <Resource
        value={tweets}
        onResolved={(result) => (
          <SSRTwitterCarousel data={result} />
        )}
      />
      <StaticPromptRecommendation />
    </Layout>
  )
})
```

When the Qwik server receives a page request, it starts the rendering process on the server. The "useEndPoint" function invokes the "onGet" function on the server and fetches the twitter feed. The "Resource" component will pause the rendering until the twitter data is resolved or rejected. Once the rendering is completed, the server responds to the client with rendered HTML.

We can observe the server side rendering behavior in the performance profile:

<img
  src="/optimized/articles/qwik-vs-next/qwik-perf.webp"
  alt="Qwik performance"
  width="100%"
  className="rounded centered"
  loading="lazy"
/>

The lead time to respond to the client is blocked by the server side data fetching and component rendering.

## Next.js SSR and Streaming

The component structure:

```tsx:next/app/page.tsx
export default async function Page() {
  const tweets = await fetchTweets();
  return (
    <Layout>
      <DallePromptAndResult />
      <Suspense fallback={<Skeleton />}>
        <SSRTwitterCarousel data={tweets} />
      </Suspense>
      <StaticPromptRecommendation />
    </Layout>
  )
}
```

The "Page" component is a server component. It looks just like a normal component but it supports async/await.

When the Next.js server receives a page request, it starts the rendering process and [streaming][26] the rendering result to the client so that the client can progressively render and display the UI to the users. While the server is fetching twitter feeds, React renders the suspense placeholder to indicate the pending state. Once the data is resolved or rejected, React reveals the suspense boundary and displays the final UI.

<img
  src="/optimized/articles/qwik-vs-next/sc-perf.webp"
  alt="Next with server component performance"
  width="100%"
  className="rounded centered"
  loading="lazy"
/>

You can see the client starts rendering while the server is streaming. It reduces the lead time for the users to start seeing the page.

## Resumability v.s. React Server Component

> Qwik embraces the "Get HTML and render" mental model.

[Resumability][6] is Qwik's innovation. It allows an application to be rendered as much as possible on the server and resumes the rest of the rendering on the client.

The framework looks like this:

<img
  src="/optimized/articles/qwik-vs-next/qwik.webp"
  alt="Next with server component performance"
  width="100%"
  className="rounded centered"
  loading="lazy"
/>

When receiving a request, the Qwik server starts the rendering process and generate

- serialized application state,
- serialized event handlers,
- component HTMLs,
- and component code chunks.

The server then responds to the client with the page HTML and the serialized state.

<img
  src="/optimized/articles/qwik-vs-next/qwik-network.webp"
  alt="Next with server component performance"
  width="100%"
  className="rounded centered"
  loading="lazy"
/>

On the client, the browser processes the [critical rendering path][12] and displays the UI. Qwik deserializes the state after the page HTML is loaded. The state contains all the local states of each component. The lazy loaded components are able to be dynamically imported independently without knowing the parent's state because they can refer to the deserialized state for their local states when they are rendering on the client.

Qwik also serializes event handlers.

<img
  src="/optimized/articles/qwik-vs-next/qwik-serd.webp"
  alt="Qwik serialization"
  width="100%"
  className="rounded centered"
  loading="lazy"
/>

In the server-generated HTML, the event handlers are referenced as dynamic JavaScript chunks. When users interact with an interactive element, Qwik uses the reference to dynamically download the chunk from the server and fire the event with the event handler inside the chunk.

<img
  src="/articles/qwik-vs-next/qwik-dynamic-import.gif"
  alt="Qwik dynamic import"
  width="100%"
  className="rounded centered"
  loading="lazy"
/>

On the other hand, Next.js has a different approach to server side rendering.

> Next.js and React server component promotes the "Render while fetching" mental model.

[Next.js 13 introduces React server component as an experimental feature][13]. [Server component][14] is a special type of component that can only be rendered on the server. Combining with Suspense and Streaming, the framework is able to progressively render interactive UI while avoiding long data requests from blocking the page rendering.

The framework looks like this:

<img
  src="/optimized/articles/qwik-vs-next/next.webp"
  alt="Next.js and React Server Component"
  width="100%"
  className="rounded centered"
  loading="lazy"
/>

When Next.js server receives a request, it delegates React to handle rendering. On the server, React renders the component tree into a UI description in JSON instead of native HTML. The UI description describes the entire component tree. For the client components, React describes them as components for the client to handle with serialized props. For the server components, React renders them to native HTMLs and places them in the UI description.

On the client, React receives and reconciles the UI description in the response stream to progressively render the UI. When React sees a suspense boundary, it renders the suspense placeholder until the pending data is resolved and reveals the suspense boundary.

Because React receives a UI description instead of native HTML on the client, it needs to construct the component tree, render the UI, and attach event handlers on the client. It's known as hydration.

<img
  src="/optimized/articles/qwik-vs-next/sc-perf-2.webp"
  alt="Next.js and React Server Component"
  width="100%"
  className="rounded centered"
  loading="lazy"
/>

## Final Thoughts

Qwik's concept of [serializing states and event handlers][4] is very innovative. The client is able to render the page with just HTML and minimal JavaScript. It reduces the amount of JavaScript the client needs to download for the initial load and leverages dynamic import to download event handlers and components on the fly. We can clearly observe the benefit from the benchmark and performance profile.

However, the combination of React server component, suspense, and streaming has a profound impact on user experience. Users are able to see and interact with the content of the page without waiting for server side data fetching to complete.

The result of the experiment is not conclusive to me. Both frameworks performed well in the benchmarks. The differences in First Content Paint, Largest Content Paint, and Cumulative Layout Shift are likely a result of different Twitter images.

## References

- [API Reference: Create image][1] - OpenAI
- [Case Study][9] - web.dev
- [Critical rendering path][12] - MDN
- [DALL·E 2][0] - OpenAI
- [Data Fetching Fundamentals][17] - Next.js
- [First class support for promises][19] - Andrew Clark
- [How Rakuten 24's investment in Core Web Vitals increased revenue per visitor by 53.37% and conversion rate by 33.13%][27] - web.dev
- [Hydration is Pure Overhead][4] - Builder.io
- [Lighthouse performance scoring][10] - Chrome Developers
- [Lazy loading][11] - MDN
- [Next.js][28] - Vercel
- [Node.js library][2] - OpenAI
- [Populating the page: how browsers work][16] - MDN
- [Progressively][7] - Builder.io
- [qwik][3] - Builder.io
- [qwik-vs-next][18] - Daw-Chih Liou
- [RFC: React Server Components][14] - React Community
- [Resumable vs. Hydration][6] - Builder.io
- [Reactivity][8] - Builder.io
- [Server and Client Components][13] - Next.js
- [The "why" of web performance][15] - MDN
- [Think Qwik][5] - Builder.io
- [Time to Interfactive][24] - Chrome Developers
- [Total Blocking Time][23] - Chrome Developers
- [Twitter API v2][20] - Twitter Developer Aplatform
- [Web Vitals][21] - web.dev
- [Speed Index][22] - Chrome Developers
- [Largest Contentful Paint][25] - Chrome Developers

[0]: https://openai.com/dall-e-2/
[1]: https://beta.openai.com/docs/api-reference/images/create
[2]: https://beta.openai.com/docs/libraries/node-js-library
[3]: https://qwik.builder.io
[4]: https://www.builder.io/blog/hydration-is-pure-overhead
[5]: https://qwik.builder.io/docs/think-qwik/
[6]: https://qwik.builder.io/docs/concepts/resumable/
[7]: https://qwik.builder.io/docs/concepts/progressive/
[8]: https://qwik.builder.io/docs/concepts/reactivity/
[9]: https://web.dev/tags/case-study/
[10]: https://developer.chrome.com/docs/lighthouse/performance/performance-scoring/
[11]: https://developer.mozilla.org/en-US/docs/Web/Performance/Lazy_loading
[12]: https://developer.mozilla.org/en-US/docs/Web/Performance/Critical_rendering_path
[13]: https://beta.nextjs.org/docs/rendering/server-and-client-components
[14]: https://github.com/reactjs/rfcs/blob/main/text/0188-server-components.md
[15]: https://developer.mozilla.org/en-US/docs/Learn/Performance/why_web_performance
[16]: https://developer.mozilla.org/en-US/docs/Web/Performance/How_browsers_work
[17]: https://beta.nextjs.org/docs/data-fetching/fundamentals#fetching-data-with-server-components
[18]: https://github.com/DawChihLiou/qwik-vs-next
[19]: https://github.com/acdlite/rfcs/blob/first-class-promises/text/0000-first-class-support-for-promises.md#seamless-integration-with-javascript-ecosystem
[20]: https://developer.twitter.com/en/docs/twitter-api
[21]: https://web.dev/vitals/
[22]: https://developer.chrome.com/en/docs/lighthouse/performance/speed-index/
[23]: https://developer.chrome.com/docs/lighthouse/performance/lighthouse-total-blocking-time/
[24]: https://developer.chrome.com/docs/lighthouse/performance/interactive/
[25]: https://developer.chrome.com/docs/lighthouse/performance/lighthouse-largest-contentful-paint/
[26]: https://beta.nextjs.org/docs/data-fetching/streaming-and-suspense
[27]: https://web.dev/rakuten/

## [28]: https://nextjs.org

Here you have it! Thanks for reading through🙌
If you find this article useful, please share it to help more people in their engineering journey.

🐦 Feel free to connect with me on [twitter](https://twitter.com/dawchihliou)!

⏭ Ready for the next article? 👉 [**Tired of Slow Code Reviews? Read this**](/articles/tired-of-slow-code-reviews)

Happy coding!
